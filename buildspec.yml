version: 0.2

phases:
  pre_build:
    commands:
      - echo "Login a Amazon ECR"
      - aws --version
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPOSITORY_URI
      - export REPOSITORY_URI=$ECR_REPOSITORY_URI
      - export COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - export IMAGE_TAG=${COMMIT_HASH:-latest}
      - echo "Repositorio:$REPOSITORY_URI"
      - echo "Tag:$IMAGE_TAG"
      - cd $CODEBUILD_SRC_DIR

  build:
    commands:
      - echo "Login a ECR Public Gallery para imágenes base sin límites..."
      - aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws 2>/dev/null || echo "⚠️  No se pudo hacer login a ECR Public, continuando..."
      - echo "Build iniciado el $(date)"
      - echo "=== Pre-pull de imagen base desde ECR Public ==="
      - docker pull public.ecr.aws/docker/library/node:20-alpine || echo "⚠️  No se pudo hacer pull, continuando..."
      - echo "=== Iniciando build ==="
      - docker build --no-cache --pull -f Dockerfile.prod -t $REPOSITORY_URI:$IMAGE_TAG .
      - docker tag $REPOSITORY_URI:$IMAGE_TAG $REPOSITORY_URI:latest

  post_build:
    commands:
      - echo "Push de imagen a ECR"
      - docker push $REPOSITORY_URI:$IMAGE_TAG
      - docker push $REPOSITORY_URI:latest
      - echo "Actualizando instancias EC2..."
      - |
        TARGET_IMAGE="$REPOSITORY_URI:$IMAGE_TAG"
        PROJECT_NAME="${PROJECT_NAME:-trabajoya-prod}"
        CONTAINER_NAME="${PROJECT_NAME}-backend"
        DEPLOY_REGION="${AWS_DEFAULT_REGION:-us-east-1}"
        echo "Imagen objetivo: $TARGET_IMAGE"
        echo "Region: $DEPLOY_REGION"
        echo "Buscando instancias EC2..."
        if [ -n "$EC2_INSTANCE_ID" ]; then
          INSTANCE_IDS="$EC2_INSTANCE_ID"
        else
          ASG_NAMES=$(aws autoscaling describe-auto-scaling-groups --query "AutoScalingGroups[?contains(AutoScalingGroupName,'trabajoya')||contains(AutoScalingGroupName,'prod')].AutoScalingGroupName" --output text 2>/dev/null || echo "")
          INSTANCE_IDS=""
          if [ -n "$ASG_NAMES" ]; then
            for ASG_NAME in $ASG_NAMES; do
              ASG_INSTANCES=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" --query "AutoScalingGroups[0].Instances[?HealthStatus=='Healthy'&&LifecycleState=='InService'].InstanceId" --output text 2>/dev/null || echo "")
              if [ -n "$ASG_INSTANCES" ]; then
                INSTANCE_IDS="$INSTANCE_IDS $ASG_INSTANCES"
              fi
            done
          fi
        fi
        if [ -z "$INSTANCE_IDS" ]; then
          echo "No se encontraron instancias activas"
          exit 0
        fi
        echo "Instancias encontradas: $INSTANCE_IDS"
        cat > /tmp/update.sh << 'EOF'
        #!/bin/bash
        set -e
        echo "=== Actualizando contenedor ==="
        REGION="REGION_PH"
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "Region: $REGION"
        echo "Account: $ACCOUNT_ID"
        echo "Login a ECR..."
        aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin "$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com"
        echo "Descargando imagen TARGET_IMAGE_PH..."
        NEW_IMAGE="TARGET_IMAGE_PH"
        docker pull "$NEW_IMAGE" || {
          echo "Intentando con latest..."
          NEW_IMAGE="REPO_PH:latest"
          docker pull "$NEW_IMAGE" || {
            echo "ERROR: No se pudo descargar ninguna imagen"
            exit 1
          }
        }
        echo "Imagen descargada: $NEW_IMAGE"

        # Obtener la configuración completa del contenedor anterior ANTES de eliminarlo
        OLD_ENV_FILE="/tmp/old_container_env.txt"
        OLD_CMD_FILE="/tmp/old_container_cmd.txt"
        rm -f "$OLD_ENV_FILE" "$OLD_CMD_FILE"

        if docker ps -a --format '{{.Names}}' | grep -q '^CONTAINER_PH$'; then
          echo "Preservando configuración del contenedor anterior..."
          # Obtener todas las variables de entorno
          docker inspect --format='{{range .Config.Env}}{{println .}}{{end}}' CONTAINER_PH > "$OLD_ENV_FILE" 2>/dev/null || true
          # Obtener el comando original
          docker inspect --format='{{.Config.Cmd}}' CONTAINER_PH > "$OLD_CMD_FILE" 2>/dev/null || true
        fi

        # Detener y eliminar el contenedor existente
        if docker ps --format '{{.Names}}' | grep -q '^CONTAINER_PH$'; then
          echo "Deteniendo contenedor CONTAINER_PH..."
          docker stop CONTAINER_PH || true
        fi
        if docker ps -a --format '{{.Names}}' | grep -q '^CONTAINER_PH$'; then
          echo "Eliminando contenedor CONTAINER_PH..."
          docker rm CONTAINER_PH || true
        fi

        # Intentar recrear el contenedor con la nueva imagen
        echo "Recreando contenedor CONTAINER_PH con nueva imagen: $NEW_IMAGE"

        # Intentar crear el contenedor
        # Primero intentar con --env-file si tenemos las variables guardadas
        CONTAINER_CREATED=0
        
        if [ -f "$OLD_ENV_FILE" ] && [ -s "$OLD_ENV_FILE" ]; then
          echo "Intentando crear contenedor con variables de entorno del contenedor anterior..."
          echo "Variables encontradas: $(wc -l < "$OLD_ENV_FILE")"
          
          # Limpiar el archivo de env (filtrar PATH y variables problemáticas)
          CLEAN_ENV_FILE="/tmp/clean_env_file.txt"
          cat "$OLD_ENV_FILE" | grep -v '^$' | grep -v '^PATH=' > "$CLEAN_ENV_FILE" || true
          
          if [ -s "$CLEAN_ENV_FILE" ]; then
            echo "Usando --env-file con $(wc -l < "$CLEAN_ENV_FILE") variables..."
            ERROR_OUTPUT=$(docker run -d \
              --name CONTAINER_PH \
              --restart unless-stopped \
              -p 4000:4000 \
              --env-file "$CLEAN_ENV_FILE" \
              "$NEW_IMAGE" 2>&1)
            DOCKER_EXIT_CODE=$?
            
            if [ $DOCKER_EXIT_CODE -eq 0 ]; then
              CONTAINER_CREATED=1
              echo "✅ Contenedor creado con variables de entorno preservadas"
            else
              echo "⚠️  Fallo al crear con env-file (exit code: $DOCKER_EXIT_CODE)"
              echo "Error: $ERROR_OUTPUT"
              docker rm -f CONTAINER_PH 2>/dev/null || true
            fi
          fi
        fi
        
        # Si no se creó, intentar con configuración mínima
        if [ "$CONTAINER_CREATED" -eq 0 ]; then
          echo "Creando contenedor con configuración mínima (NODE_ENV=production)..."
          ERROR_OUTPUT=$(docker run -d \
            --name CONTAINER_PH \
            --restart unless-stopped \
            -p 4000:4000 \
            -e NODE_ENV=production \
            "$NEW_IMAGE" 2>&1)
          DOCKER_EXIT_CODE=$?
          
          if [ $DOCKER_EXIT_CODE -eq 0 ]; then
            CONTAINER_CREATED=1
            echo "✅ Contenedor creado con configuración mínima"
          else
            echo "❌ ERROR: No se pudo crear el contenedor (exit code: $DOCKER_EXIT_CODE)"
            echo "Error completo: $ERROR_OUTPUT"
            echo ""
            echo "Verificando si la imagen existe..."
            docker images | grep "$(echo "$NEW_IMAGE" | cut -d: -f1)" || echo "Imagen no encontrada localmente"
            echo ""
            echo "El user-data script debería recrearlo automáticamente"
          fi
        fi

        # Verificar que el contenedor está corriendo
        if [ "$CONTAINER_CREATED" -eq 1 ]; then
          sleep 3
          if docker ps --format '{{.Names}}' | grep -q '^CONTAINER_PH$'; then
            echo "✅ Contenedor recreado y corriendo exitosamente"
            echo "Verificando logs iniciales (últimas 15 líneas)..."
            docker logs --tail 15 CONTAINER_PH 2>&1 || true
          else
            echo "⚠️  Contenedor creado pero no está corriendo. Verificando estado..."
            docker ps -a | grep CONTAINER_PH || true
            echo "Revisando logs del contenedor..."
            docker logs CONTAINER_PH 2>&1 | tail -20 || true
            echo "Revisando por qué el contenedor no está corriendo..."
            docker inspect CONTAINER_PH 2>&1 | grep -A 10 "State" || true
          fi
        else
          echo "⚠️  No se pudo crear el contenedor. Verificando si existe..."
          docker ps -a | grep CONTAINER_PH || echo "No hay contenedor con ese nombre"
          echo "El user-data script debería recrearlo automáticamente si es necesario"
        fi
        echo "Actualizacion completada"
        EOF
        sed -i "s|REGION_PH|${DEPLOY_REGION}|g" /tmp/update.sh
        sed -i "s|TARGET_IMAGE_PH|${TARGET_IMAGE}|g" /tmp/update.sh
        sed -i "s|REPO_PH|${REPOSITORY_URI}|g" /tmp/update.sh
        sed -i "s|CONTAINER_PH|${CONTAINER_NAME}|g" /tmp/update.sh
        for INSTANCE_ID in $INSTANCE_IDS; do
          echo ""
          echo "=== Actualizando instancia: $INSTANCE_ID ==="
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters '{"commands":["'"$(cat /tmp/update.sh | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')"'"]}' \
            --timeout-seconds 600 \
            --query 'Command.CommandId' \
            --output text 2>&1)
          if [ -z "$COMMAND_ID" ] || [ "$COMMAND_ID" = "None" ] || echo "$COMMAND_ID" | grep -q "Error"; then
            echo "ERROR: No se pudo enviar comando SSM"
            echo "$COMMAND_ID"
            continue
          fi
          echo "Comando SSM enviado: $COMMAND_ID"
          echo "Esperando respuesta..."
          WAIT_COUNT=0
          while [ $WAIT_COUNT -lt 30 ]; do
            STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'Status' --output text 2>/dev/null || echo "Pending")
            echo "  Estado: $STATUS (intento $((WAIT_COUNT + 1))/30)"
            if [ "$STATUS" = "Success" ]; then
              echo ""
              echo "✅ Instancia actualizada exitosamente"
              echo ""
              echo "Output:"
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text 2>/dev/null || echo "No output"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo ""
              echo "❌ ERROR: El comando fallo"
              echo ""
              echo "Error:"
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardErrorContent' --output text 2>/dev/null || echo "No error details"
              echo ""
              echo "Output:"
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text 2>/dev/null || echo "No output"
              break
            elif [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "⚠️  Comando $STATUS"
              break
            fi
            WAIT_COUNT=$((WAIT_COUNT + 1))
            sleep 10
          done
        done
        echo ""
        echo "=== Deployment completado ==="

artifacts:
  files:
    - "**/*"
