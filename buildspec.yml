version: 0.2

phases:
  pre_build:
    commands:
      - echo "Login a Amazon ECR"
      - aws --version
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPOSITORY_URI
      - export REPOSITORY_URI=$ECR_REPOSITORY_URI
      - export COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - export IMAGE_TAG=${COMMIT_HASH:-latest}
      - echo "Repositorio:$REPOSITORY_URI"
      - echo "Tag:$IMAGE_TAG"
      - cd $CODEBUILD_SRC_DIR

  build:
    commands:
      - echo "Login a ECR Public Gallery para imágenes base sin límites..."
      - aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws 2>/dev/null || echo "⚠️  No se pudo hacer login a ECR Public, continuando..."
      - echo "Build iniciado el $(date)"
      - echo "=== Pre-pull de imagen base desde ECR Public ==="
      - docker pull public.ecr.aws/docker/library/node:20-alpine || echo "⚠️  No se pudo hacer pull, continuando..."
      - echo "=== Iniciando build ==="
      - docker build --no-cache --pull -f Dockerfile.prod -t $REPOSITORY_URI:$IMAGE_TAG .
      - docker tag $REPOSITORY_URI:$IMAGE_TAG $REPOSITORY_URI:latest

  post_build:
    commands:
      - echo "Push de imagen a ECR"
      - docker push $REPOSITORY_URI:$IMAGE_TAG
      - docker push $REPOSITORY_URI:latest
      - echo "Actualizando instancias EC2..."
      - |
        TARGET_IMAGE="$REPOSITORY_URI:$IMAGE_TAG"
        PROJECT_NAME="${PROJECT_NAME:-trabajoya-prod}"
        CONTAINER_NAME="${PROJECT_NAME}-backend"
        DEPLOY_REGION="${AWS_DEFAULT_REGION:-us-east-1}"
        echo "Imagen objetivo: $TARGET_IMAGE"
        echo "Region: $DEPLOY_REGION"
        echo "Buscando instancias EC2..."
        if [ -n "$EC2_INSTANCE_ID" ]; then
          INSTANCE_IDS="$EC2_INSTANCE_ID"
        else
          ASG_NAMES=$(aws autoscaling describe-auto-scaling-groups --query "AutoScalingGroups[?contains(AutoScalingGroupName,'trabajoya')||contains(AutoScalingGroupName,'prod')].AutoScalingGroupName" --output text 2>/dev/null || echo "")
          INSTANCE_IDS=""
          if [ -n "$ASG_NAMES" ]; then
            for ASG_NAME in $ASG_NAMES; do
              ASG_INSTANCES=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" --query "AutoScalingGroups[0].Instances[?HealthStatus=='Healthy'&&LifecycleState=='InService'].InstanceId" --output text 2>/dev/null || echo "")
              if [ -n "$ASG_INSTANCES" ]; then
                INSTANCE_IDS="$INSTANCE_IDS $ASG_INSTANCES"
              fi
            done
          fi
        fi
        if [ -z "$INSTANCE_IDS" ]; then
          echo "No se encontraron instancias activas"
          exit 0
        fi
        echo "Instancias encontradas: $INSTANCE_IDS"
        cat > /tmp/update.sh << 'EOF'
        #!/bin/bash
        set -e
        echo "=== Actualizando contenedor ==="
        REGION="REGION_PH"
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "Region: $REGION"
        echo "Account: $ACCOUNT_ID"
        echo "Login a ECR..."
        aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin "$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com"
        echo "Descargando imagen TARGET_IMAGE_PH..."
        NEW_IMAGE="TARGET_IMAGE_PH"
        docker pull "$NEW_IMAGE" || {
          echo "Intentando con latest..."
          NEW_IMAGE="REPO_PH:latest"
          docker pull "$NEW_IMAGE" || {
            echo "ERROR: No se pudo descargar ninguna imagen"
            exit 1
          }
        }
        echo "Imagen descargada: $NEW_IMAGE"

        # Obtener la configuración completa del contenedor anterior ANTES de eliminarlo
        OLD_ENV_FILE="/tmp/old_container_env.txt"
        OLD_CMD_FILE="/tmp/old_container_cmd.txt"
        rm -f "$OLD_ENV_FILE" "$OLD_CMD_FILE"

        if docker ps -a --format '{{.Names}}' | grep -q '^CONTAINER_PH$'; then
          echo "Preservando configuración del contenedor anterior..."
          # Obtener todas las variables de entorno
          docker inspect --format='{{range .Config.Env}}{{println .}}{{end}}' CONTAINER_PH > "$OLD_ENV_FILE" 2>/dev/null || true
          # Obtener el comando original
          docker inspect --format='{{.Config.Cmd}}' CONTAINER_PH > "$OLD_CMD_FILE" 2>/dev/null || true
        fi

        # Detener y eliminar el contenedor existente
        if docker ps --format '{{.Names}}' | grep -q '^CONTAINER_PH$'; then
          echo "Deteniendo contenedor CONTAINER_PH..."
          docker stop CONTAINER_PH || true
        fi
        if docker ps -a --format '{{.Names}}' | grep -q '^CONTAINER_PH$'; then
          echo "Eliminando contenedor CONTAINER_PH..."
          docker rm CONTAINER_PH || true
        fi

        # Intentar recrear el contenedor con la nueva imagen
        echo "Recreando contenedor CONTAINER_PH con nueva imagen: $NEW_IMAGE"

        # Intentar crear el contenedor
        # Primero intentar con --env-file si tenemos las variables guardadas
        CONTAINER_CREATED=0

        if [ -f "$OLD_ENV_FILE" ] && [ -s "$OLD_ENV_FILE" ]; then
          echo "Intentando crear contenedor con variables de entorno del contenedor anterior..."
          echo "Variables encontradas: $(wc -l < "$OLD_ENV_FILE")"
          
          # Limpiar el archivo de env (filtrar PATH y variables problemáticas)
          CLEAN_ENV_FILE="/tmp/clean_env_file.txt"
          cat "$OLD_ENV_FILE" | grep -v '^$' | grep -v '^PATH=' > "$CLEAN_ENV_FILE" || true
          
          if [ -s "$CLEAN_ENV_FILE" ]; then
            echo "Usando --env-file con $(wc -l < "$CLEAN_ENV_FILE") variables..."
            DOCKER_OUTPUT=$(docker run -d \
              --name CONTAINER_PH \
              --restart unless-stopped \
              -p 4000:4000 \
              --env-file "$CLEAN_ENV_FILE" \
              "$NEW_IMAGE" 2>&1)
            DOCKER_EXIT_CODE=$?
            
            if [ $DOCKER_EXIT_CODE -eq 0 ]; then
              CONTAINER_CREATED=1
              echo "✅ Contenedor creado con variables de entorno preservadas"
              echo "Container ID: $DOCKER_OUTPUT"
            else
              echo "⚠️  Fallo al crear con env-file (exit code: $DOCKER_EXIT_CODE)"
              echo "Error: $DOCKER_OUTPUT"
              docker rm -f CONTAINER_PH 2>/dev/null || true
            fi
          fi
        fi

        # Si no se creó, intentar obtener variables de entorno desde SSM Parameter Store
        if [ "$CONTAINER_CREATED" -eq 0 ]; then
          echo "Intentando obtener variables de entorno desde SSM Parameter Store..."
          STACK_PREFIX="${STACK_PREFIX:-trabajoya-prod}"
          SSM_ENV_FILE="/tmp/ssm_env_file.txt"
          rm -f "$SSM_ENV_FILE"
          
          # Lista de variables críticas a obtener desde SSM
          SSM_PARAMS=(
            "DATABASE_URL"
            "DATABASE_SECRET_ARN"
            "DATABASE_ENDPOINT"
            "DATABASE_NAME"
            "APP_SECRETS_ARN"
            "AWS_REGION"
            "STACK_PREFIX"
            "JWT_ACCESS_SECRET"
            "JWT_REFRESH_SECRET"
            "S3_BUCKET_NAME"
            "CLOUDFRONT_DOMAIN"
          )
          
          ENV_VARS_COUNT=0
          for PARAM_NAME in "${SSM_PARAMS[@]}"; do
            # Convertir a minúsculas de forma compatible
            PARAM_LOWER=$(echo "$PARAM_NAME" | tr '[:upper:]' '[:lower:]')
            
            # Intentar obtener desde SSM con diferentes prefijos posibles
            SSM_NAMES=(
              "${STACK_PREFIX}/${PARAM_LOWER}"
              "${STACK_PREFIX}/env/${PARAM_LOWER}"
              "/${STACK_PREFIX}/${PARAM_LOWER}"
              "/${STACK_PREFIX}/env/${PARAM_LOWER}"
              "${PARAM_NAME}"
              "${PARAM_LOWER}"
            )
            
            VALUE_FOUND=0
            for SSM_NAME in "${SSM_NAMES[@]}"; do
              VALUE=$(aws ssm get-parameter --name "$SSM_NAME" --with-decryption --query 'Parameter.Value' --output text 2>/dev/null || echo "")
              if [ -n "$VALUE" ] && [ "$VALUE" != "None" ]; then
                echo "${PARAM_NAME}=${VALUE}" >> "$SSM_ENV_FILE"
                echo "✅ Obtenido ${PARAM_NAME} desde SSM: ${SSM_NAME}"
                ENV_VARS_COUNT=$((ENV_VARS_COUNT + 1))
                VALUE_FOUND=1
                break
              fi
            done
            
            if [ "$VALUE_FOUND" -eq 0 ]; then
              echo "⚠️  No se encontró ${PARAM_NAME} en SSM Parameter Store"
            fi
          done
          
          # Si obtuvimos variables desde SSM, intentar crear el contenedor con ellas
          if [ -f "$SSM_ENV_FILE" ] && [ -s "$SSM_ENV_FILE" ] && [ "$ENV_VARS_COUNT" -gt 0 ]; then
            echo "Usando variables de entorno desde SSM (${ENV_VARS_COUNT} variables encontradas)..."
            # Agregar NODE_ENV=production si no está presente
            if ! grep -q "^NODE_ENV=" "$SSM_ENV_FILE"; then
              echo "NODE_ENV=production" >> "$SSM_ENV_FILE"
            fi
            
            DOCKER_OUTPUT=$(docker run -d \
              --name CONTAINER_PH \
              --restart unless-stopped \
              -p 4000:4000 \
              --env-file "$SSM_ENV_FILE" \
              "$NEW_IMAGE" 2>&1)
            DOCKER_EXIT_CODE=$?
            
            if [ $DOCKER_EXIT_CODE -eq 0 ]; then
              CONTAINER_CREATED=1
              echo "✅ Contenedor creado con variables de entorno desde SSM"
              echo "Container ID: $DOCKER_OUTPUT"
            else
              echo "⚠️  Fallo al crear con variables de SSM (exit code: $DOCKER_EXIT_CODE)"
              echo "Error: $DOCKER_OUTPUT"
              docker rm -f CONTAINER_PH 2>/dev/null || true
            fi
          else
            echo "⚠️  No se encontraron variables de entorno en SSM Parameter Store"
          fi
        fi
        
        # Si aún no se creó, intentar con configuración mínima
        if [ "$CONTAINER_CREATED" -eq 0 ]; then
          echo "Creando contenedor con configuración mínima (NODE_ENV=production)..."
          echo "⚠️  ADVERTENCIA: El contenedor se crea sin variables de entorno críticas."
          echo "⚠️  La aplicación puede fallar si necesita DATABASE_URL u otras variables."
          echo "Imagen: $NEW_IMAGE"
          echo "Comando completo: docker run -d --name CONTAINER_PH --restart unless-stopped -p 4000:4000 -e NODE_ENV=production \"$NEW_IMAGE\""
          
          # Verificar que la imagen existe antes de intentar crear el contenedor
          echo "Verificando que la imagen existe..."
          if docker images --format "{{.Repository}}:{{.Tag}}" | grep -q "^$(echo "$NEW_IMAGE" | cut -d: -f1):$(echo "$NEW_IMAGE" | cut -d: -f2)$"; then
            echo "✅ Imagen encontrada localmente"
          else
            echo "⚠️  Imagen no encontrada con formato exacto, listando imágenes similares..."
            docker images | grep "$(echo "$NEW_IMAGE" | cut -d: -f1)" || echo "No se encontraron imágenes similares"
          fi
          
          # Verificar si el puerto está en uso
          echo "Verificando puerto 4000..."
          if docker ps --format "{{.Ports}}" | grep -q "4000"; then
            echo "⚠️  Puerto 4000 está en uso por otro contenedor:"
            docker ps --filter "publish=4000"
          else
            echo "✅ Puerto 4000 está disponible"
          fi
          
          # Ejecutar docker run y capturar tanto stdout como stderr
          echo ""
          echo "Ejecutando docker run..."
          set +e  # No salir en error para poder capturar el resultado
          DOCKER_OUTPUT=$(docker run -d \
            --name CONTAINER_PH \
            --restart unless-stopped \
            -p 4000:4000 \
            -e NODE_ENV=production \
            "$NEW_IMAGE" 2>&1)
          DOCKER_EXIT_CODE=$?
          set -e  # Volver a activar exit on error
          
          echo "=========================================="
          echo "RESULTADO DEL DOCKER RUN:"
          echo "Exit code: $DOCKER_EXIT_CODE"
          echo "Output completo:"
          echo "$DOCKER_OUTPUT"
          echo "=========================================="
          
          if [ $DOCKER_EXIT_CODE -eq 0 ] && [ -n "$DOCKER_OUTPUT" ]; then
            CONTAINER_CREATED=1
            echo "✅ Contenedor creado con configuración mínima"
            echo "Container ID: $DOCKER_OUTPUT"
          else
            echo "❌ ERROR: No se pudo crear el contenedor"
            echo "Exit code: $DOCKER_EXIT_CODE"
            echo "Output: $DOCKER_OUTPUT"
            echo ""
            echo "Diagnóstico adicional:"
            echo "- Verificando si el contenedor existe (aunque haya fallado)..."
            docker ps -a | grep CONTAINER_PH || echo "No existe ningún contenedor con ese nombre"
            echo ""
            echo "El user-data script debería recrearlo automáticamente"
          fi
        fi

        # Verificar que el contenedor está corriendo
        echo ""
        echo "=== Verificación final del contenedor ==="

        # Siempre verificar si existe el contenedor, independientemente de CONTAINER_CREATED
        if docker ps -a --format '{{.Names}}' | grep -q '^CONTAINER_PH$'; then
          echo "Contenedor encontrado en el sistema Docker"
          
          if docker ps --format '{{.Names}}' | grep -q '^CONTAINER_PH$'; then
            echo "✅ Contenedor está corriendo"
            echo ""
            echo "Información del contenedor:"
            docker ps --filter "name=CONTAINER_PH" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            echo ""
            echo "Verificando logs iniciales (últimas 20 líneas)..."
            docker logs --tail 20 CONTAINER_PH 2>&1 || true
          else
            echo "⚠️  Contenedor existe pero NO está corriendo"
            echo ""
            echo "Estado del contenedor:"
            docker ps -a --filter "name=CONTAINER_PH" --format "table {{.Names}}\t{{.Status}}\t{{.CreatedAt}}"
            echo ""
            echo "Revisando logs del contenedor (últimas 30 líneas)..."
            docker logs --tail 30 CONTAINER_PH 2>&1 || echo "No se pudieron obtener logs"
            echo ""
            echo "Revisando estado detallado del contenedor..."
            docker inspect CONTAINER_PH 2>&1 | grep -A 15 '"State"' || echo "No se pudo inspeccionar el contenedor"
            echo ""
            echo "Intentando iniciar el contenedor..."
            docker start CONTAINER_PH 2>&1 || echo "No se pudo iniciar el contenedor"
            sleep 2
            if docker ps --format '{{.Names}}' | grep -q '^CONTAINER_PH$'; then
              echo "✅ Contenedor iniciado exitosamente"
            else
              echo "❌ Contenedor no se pudo iniciar. Revisando logs de error..."
              docker logs CONTAINER_PH 2>&1 | tail -10 || true
            fi
          fi
        else
          echo "❌ No se encontró ningún contenedor con el nombre CONTAINER_PH"
          echo ""
          echo "Listando todos los contenedores (activos y detenidos):"
          docker ps -a || echo "Error al listar contenedores"
          echo ""
          if [ "$CONTAINER_CREATED" -eq 0 ]; then
            echo "El script de actualización no pudo crear el contenedor."
            echo "El user-data script debería recrearlo automáticamente si es necesario"
          else
            echo "El script reportó que creó el contenedor, pero no se encuentra en el sistema."
            echo "Esto podría indicar un problema con Docker o con el nombre del contenedor."
          fi
        fi
        echo ""
        echo "=== Actualizacion completada ==="
        EOF
        sed -i "s|REGION_PH|${DEPLOY_REGION}|g" /tmp/update.sh
        sed -i "s|TARGET_IMAGE_PH|${TARGET_IMAGE}|g" /tmp/update.sh
        sed -i "s|REPO_PH|${REPOSITORY_URI}|g" /tmp/update.sh
        sed -i "s|CONTAINER_PH|${CONTAINER_NAME}|g" /tmp/update.sh
        # Codificar el script en base64 para evitar problemas de escape JSON
        SCRIPT_B64=$(base64 -w 0 /tmp/update.sh)
        for INSTANCE_ID in $INSTANCE_IDS; do
          echo ""
          echo "=== Actualizando instancia: $INSTANCE_ID ==="
          # Usar base64 para evitar problemas de escape JSON
          # Construir el JSON de forma segura usando jq si está disponible, sino usar método alternativo
          if command -v jq &> /dev/null; then
            SSM_COMMAND=$(jq -n --arg script "$SCRIPT_B64" '{"commands":["echo " + $script + " | base64 -d > /tmp/update_remote.sh && chmod +x /tmp/update_remote.sh && /tmp/update_remote.sh"]}')
          else
            # Fallback: construir JSON manualmente (base64 solo contiene caracteres seguros)
            SSM_COMMAND="{\"commands\":[\"echo $SCRIPT_B64 | base64 -d > /tmp/update_remote.sh && chmod +x /tmp/update_remote.sh && /tmp/update_remote.sh\"]}"
          fi
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "$SSM_COMMAND" \
            --timeout-seconds 600 \
            --query 'Command.CommandId' \
            --output text 2>&1)
          if [ -z "$COMMAND_ID" ] || [ "$COMMAND_ID" = "None" ] || echo "$COMMAND_ID" | grep -q "Error"; then
            echo "ERROR: No se pudo enviar comando SSM"
            echo "$COMMAND_ID"
            continue
          fi
          echo "Comando SSM enviado: $COMMAND_ID"
          echo "Esperando respuesta..."
          WAIT_COUNT=0
          while [ $WAIT_COUNT -lt 30 ]; do
            STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'Status' --output text 2>/dev/null || echo "Pending")
            echo "  Estado: $STATUS (intento $((WAIT_COUNT + 1))/30)"
            if [ "$STATUS" = "Success" ]; then
              echo ""
              echo "✅ Instancia actualizada exitosamente"
              echo ""
              echo "Output:"
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text 2>/dev/null || echo "No output"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo ""
              echo "❌ ERROR: El comando fallo"
              echo ""
              echo "Error:"
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardErrorContent' --output text 2>/dev/null || echo "No error details"
              echo ""
              echo "Output:"
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text 2>/dev/null || echo "No output"
              break
            elif [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "⚠️  Comando $STATUS"
              break
            fi
            WAIT_COUNT=$((WAIT_COUNT + 1))
            sleep 10
          done
        done
        echo ""
        echo "=== Deployment completado ==="

artifacts:
  files:
    - "**/*"
