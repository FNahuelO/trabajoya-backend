version: 0.2

env:
  variables:
    DATABASE_URL_SECRET_ID: /trabajoya-prod/env/DATABASE_URL

phases:
  pre_build:
    commands:
      - echo "Login a Amazon ECR"
      - aws --version
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPOSITORY_URI
      - export REPOSITORY_URI=$ECR_REPOSITORY_URI
      - export COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - export IMAGE_TAG=${COMMIT_HASH:-latest}
      - echo "Repositorio:$REPOSITORY_URI"
      - echo "Tag:$IMAGE_TAG"
      - cd $CODEBUILD_SRC_DIR

  build:
    commands:
      - echo "Login a ECR Public Gallery para imágenes base sin límites..."
      - aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws 2>/dev/null || echo "⚠️  No se pudo hacer login a ECR Public, continuando..."
      - echo "Build iniciado el $(date)"
      - echo "=== Pre-pull de imagen base desde ECR Public ==="
      - docker pull public.ecr.aws/docker/library/node:20-alpine || echo "⚠️  No se pudo hacer pull, continuando..."
      - echo "=== Iniciando build ==="
      - docker build --no-cache --pull -f Dockerfile.prod -t $REPOSITORY_URI:$IMAGE_TAG .
      - docker tag $REPOSITORY_URI:$IMAGE_TAG $REPOSITORY_URI:latest

  post_build:
    commands:
      - echo "Push de imagen a ECR"
      - docker push $REPOSITORY_URI:$IMAGE_TAG
      - docker push $REPOSITORY_URI:latest
      - echo "Actualizando instancias EC2..."
      - |
        TARGET_IMAGE="$REPOSITORY_URI:$IMAGE_TAG"
        PROJECT_NAME="${PROJECT_NAME:-trabajoya-prod}"
        CONTAINER_NAME="${PROJECT_NAME}-backend"
        DEPLOY_REGION="${AWS_DEFAULT_REGION:-us-east-1}"
        echo "Imagen objetivo: $TARGET_IMAGE"
        echo "Region: $DEPLOY_REGION"
        echo "Buscando instancias EC2..."

        if [ -n "$EC2_INSTANCE_ID" ]; then
          INSTANCE_IDS="$EC2_INSTANCE_ID"
        else
          ASG_NAMES=$(aws autoscaling describe-auto-scaling-groups --query "AutoScalingGroups[?contains(AutoScalingGroupName,'trabajoya')||contains(AutoScalingGroupName,'prod')].AutoScalingGroupName" --output text 2>/dev/null || echo "")
          INSTANCE_IDS=""
          if [ -n "$ASG_NAMES" ]; then
            for ASG_NAME in $ASG_NAMES; do
              ASG_INSTANCES=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" --query "AutoScalingGroups[0].Instances[?HealthStatus=='Healthy'&&LifecycleState=='InService'].InstanceId" --output text 2>/dev/null || echo "")
              if [ -n "$ASG_INSTANCES" ]; then
                INSTANCE_IDS="$INSTANCE_IDS $ASG_INSTANCES"
              fi
            done
          fi
        fi

        if [ -z "$INSTANCE_IDS" ]; then
          echo "No se encontraron instancias activas"
          exit 0
        fi

        echo "Instancias encontradas: $INSTANCE_IDS"

        cat > /tmp/update.sh << 'EOF'
        #!/bin/bash
        set -euo pipefail

        echo "=== Actualizando contenedor ==="
        REGION="REGION_PH"
        TARGET_IMAGE="TARGET_IMAGE_PH"
        REPOSITORY_URI="REPO_PH"
        CONTAINER_NAME="CONTAINER_PH"
        DATABASE_URL_SECRET_ID="DB_SECRET_PH"

        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

        echo "Region: $REGION"
        echo "Account: $ACCOUNT_ID"

        echo "Login a ECR..."
        aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin "$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com"

        echo "Pull imagen..."
        docker pull "$TARGET_IMAGE" || {
          echo "Intentando con latest..."
          docker pull "$REPOSITORY_URI:latest"
          TARGET_IMAGE="$REPOSITORY_URI:latest"
        }

        echo "Obteniendo DATABASE_URL desde Secrets Manager: $DATABASE_URL_SECRET_ID"
        DATABASE_URL=$(aws secretsmanager get-secret-value \
          --secret-id "$DATABASE_URL_SECRET_ID" \
          --query SecretString \
          --output text)

        if [ -z "$DATABASE_URL" ] || [ "$DATABASE_URL" = "None" ]; then
          echo "❌ ERROR: DATABASE_URL no encontrado en Secrets Manager ($DATABASE_URL_SECRET_ID)"
          exit 1
        fi

        echo "Deteniendo contenedor si existe..."
        docker stop "$CONTAINER_NAME" 2>/dev/null || true
        docker rm "$CONTAINER_NAME" 2>/dev/null || true

        echo "Recreando contenedor con DATABASE_URL..."
        docker run -d \
          --name "$CONTAINER_NAME" \
          --restart unless-stopped \
          -p 4000:4000 \
          -e NODE_ENV=production \
          -e DATABASE_URL="$DATABASE_URL" \
          "$TARGET_IMAGE"

        echo "=== Verificación ==="
        docker ps --filter "name=$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        echo "Logs (tail 30):"
        docker logs --tail 30 "$CONTAINER_NAME" || true
        echo "=== Deploy OK ==="
        EOF

        sed -i "s|REGION_PH|${DEPLOY_REGION}|g" /tmp/update.sh
        sed -i "s|TARGET_IMAGE_PH|${TARGET_IMAGE}|g" /tmp/update.sh
        sed -i "s|REPO_PH|${REPOSITORY_URI}|g" /tmp/update.sh
        sed -i "s|CONTAINER_PH|${CONTAINER_NAME}|g" /tmp/update.sh
        sed -i "s|DB_SECRET_PH|${DATABASE_URL_SECRET_ID}|g" /tmp/update.sh

        SCRIPT_B64=$(base64 -w 0 /tmp/update.sh)

        for INSTANCE_ID in $INSTANCE_IDS; do
          echo ""
          echo "=== Actualizando instancia: $INSTANCE_ID ==="

          SSM_COMMAND=$(jq -n --arg script "$SCRIPT_B64" \
            '{"commands":["echo " + $script + " | base64 -d > /tmp/update_remote.sh && chmod +x /tmp/update_remote.sh && /tmp/update_remote.sh"]}')

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "$SSM_COMMAND" \
            --timeout-seconds 600 \
            --query 'Command.CommandId' \
            --output text)

          echo "Comando SSM enviado: $COMMAND_ID"
          echo "Esperando respuesta..."

          WAIT_COUNT=0
          while [ $WAIT_COUNT -lt 30 ]; do
            STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'Status' --output text 2>/dev/null || echo "Pending")
            echo "  Estado: $STATUS (intento $((WAIT_COUNT + 1))/30)"

            if [ "$STATUS" = "Success" ]; then
              echo "✅ Instancia actualizada exitosamente"
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text 2>/dev/null || true
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "TimedOut" ] || [ "$STATUS" = "Cancelled" ]; then
              echo "❌ ERROR deploy: $STATUS"
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardErrorContent' --output text 2>/dev/null || true
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text 2>/dev/null || true
              exit 1
            fi

            WAIT_COUNT=$((WAIT_COUNT + 1))
            sleep 10
          done
        done

        echo "=== Deployment completado ==="

artifacts:
  files:
    - "**/*"
