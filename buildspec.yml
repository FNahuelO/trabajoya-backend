version: 0.2

phases:
  pre_build:
    commands:
      - echo "Login a Amazon ECR"
      - aws --version
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPOSITORY_URI
      - |
        export REPOSITORY_URI=$ECR_REPOSITORY_URI
        export COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
        export IMAGE_TAG=${COMMIT_HASH:-latest}
        echo "Repositorio: $REPOSITORY_URI"
        echo "Tag: $IMAGE_TAG"
      - cd $CODEBUILD_SRC_DIR

  build:
    commands:
      - echo "Build iniciado el $(date)"
      - echo "Verificando si la imagen ya existe en ECR..."
      - |
        ECR_REPO_NAME=$(echo $ECR_REPOSITORY_URI | cut -d'/' -f2)
        if aws ecr describe-images --repository-name $ECR_REPO_NAME --image-ids imageTag=$IMAGE_TAG 2>/dev/null; then
          echo "‚ö†Ô∏è  Imagen con tag $IMAGE_TAG ya existe. Verificando si hay cambios..."
          OLD_DIGEST=$(aws ecr describe-images --repository-name $ECR_REPO_NAME --image-ids imageTag=$IMAGE_TAG --query 'imageDetails[0].imageDigest' --output text)
          echo "Digest actual: $OLD_DIGEST"
          export OLD_DIGEST
        else
          echo "‚úÖ Imagen nueva, procediendo con build..."
        fi
      - docker build -f Dockerfile.prod -t $REPOSITORY_URI:$IMAGE_TAG .
      - docker tag $REPOSITORY_URI:$IMAGE_TAG $REPOSITORY_URI:latest
      - |
        NEW_DIGEST=$(docker inspect $REPOSITORY_URI:$IMAGE_TAG --format='{{index .RepoDigests 0}}' | cut -d'@' -f2 || echo "new-image")
        echo "Nuevo digest: $NEW_DIGEST"
        if [ -n "$OLD_DIGEST" ] && [ "$NEW_DIGEST" = "$OLD_DIGEST" ]; then
          echo "‚ö†Ô∏è  La imagen no ha cambiado. Marcando para skip de deployment..."
          echo "SKIP_DEPLOY=true" > /tmp/build.env
        else
          echo "‚úÖ Imagen nueva o modificada. Deployment necesario."
          echo "SKIP_DEPLOY=false" > /tmp/build.env
        fi

  post_build:
    commands:
      - echo "Push de imagen a ECR"
      - docker push $REPOSITORY_URI:$IMAGE_TAG
      - docker push $REPOSITORY_URI:latest

      - echo "‚úÖ Migraciones se ejecutar√°n autom√°ticamente al iniciar el contenedor"
      - echo "üí° Esto no tiene costo adicional - las migraciones corren en el mismo contenedor"

      - echo "üîÑ Actualizando instancias EC2 existentes (sin crear nuevas)..."
      - |
        source /tmp/build.env 2>/dev/null || SKIP_DEPLOY="false"

        if [ "$SKIP_DEPLOY" = "true" ]; then
          echo "‚è≠Ô∏è  Saltando deployment - imagen no ha cambiado"
          exit 0
        fi

        TARGET_IMAGE="$REPOSITORY_URI:$IMAGE_TAG"
        PROJECT_NAME="${PROJECT_NAME:-trabajoya-prod}"
        CONTAINER_NAME="${PROJECT_NAME}-backend"

        echo "Imagen objetivo: $TARGET_IMAGE"
        echo "Nombre del contenedor: $CONTAINER_NAME"

        # Buscar Auto Scaling Group por nombre
        ASG_NAME=$(aws autoscaling describe-auto-scaling-groups \
          --query "AutoScalingGroups[?contains(AutoScalingGroupName, '${PROJECT_NAME}') && contains(AutoScalingGroupName, 'ASG')].AutoScalingGroupName" \
          --output text 2>/dev/null | head -n 1)

        if [ -z "$ASG_NAME" ]; then
          echo "‚ö†Ô∏è  No se encontr√≥ Auto Scaling Group. Buscando instancias directamente..."
          # Buscar instancias por tag
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:aws:autoscaling:groupName,Values=*${PROJECT_NAME}*" \
                      "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].InstanceId" \
            --output text 2>/dev/null)
        else
          echo "‚úÖ Auto Scaling Group encontrado: $ASG_NAME"
          # Obtener IDs de instancias del ASG
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --query "AutoScalingGroups[0].Instances[?HealthStatus=='Healthy' && LifecycleState=='InService'].InstanceId" \
            --output text 2>/dev/null)
        fi

        if [ -z "$INSTANCE_IDS" ]; then
          echo "‚ö†Ô∏è  No se encontraron instancias activas"
          echo "üí° Verifica que el Auto Scaling Group tenga instancias ejecut√°ndose"
          exit 0
        fi

        echo "üìã Instancias encontradas: $INSTANCE_IDS"

        # Preparar comandos SSM para actualizar y reiniciar el contenedor
        # El script hace pull de la nueva imagen y reinicia el contenedor (si est√° configurado con restart policy)
        SSM_COMMANDS=(
          "set -e"
          "REGION=\$(curl -s http://169.254.169.254/latest/meta-data/placement/region)"
          "ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)"
          "aws ecr get-login-password --region \$REGION | docker login --username AWS --password-stdin \$ACCOUNT_ID.dkr.ecr.\$REGION.amazonaws.com"
          "docker pull ${TARGET_IMAGE} || docker pull ${REPOSITORY_URI}:latest"
          "if docker ps --format '{{.Names}}' | grep -q '^${CONTAINER_NAME}$'; then docker restart ${CONTAINER_NAME} && echo '‚úÖ Contenedor reiniciado' || (docker stop ${CONTAINER_NAME} && docker rm ${CONTAINER_NAME} && echo '‚ö†Ô∏è  Contenedor detenido - ser√° recreado por user-data o health check'); else echo '‚ö†Ô∏è  Contenedor no estaba corriendo - ser√° iniciado por user-data'; fi"
          "echo '‚úÖ Actualizaci√≥n completada'"
        )

        # Convertir array a formato JSON para SSM
        COMMANDS_JSON=$(printf '%s\n' "${SSM_COMMANDS[@]}" | jq -R . | jq -s .)

        # Enviar comando a todas las instancias para actualizar el contenedor
        for INSTANCE_ID in $INSTANCE_IDS; do
          echo "üöÄ Actualizando instancia: $INSTANCE_ID"
          
          # Usar SSM Run Command para ejecutar el script de actualizaci√≥n
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=${COMMANDS_JSON}" \
            --output-s3-bucket-name "${PROJECT_NAME}-cicd-artifacts" \
            --output-s3-key-prefix "ssm-commands" \
            --timeout-seconds 600 \
            --query 'Command.CommandId' \
            --output text 2>/dev/null)
          
          if [ -n "$COMMAND_ID" ] && [ "$COMMAND_ID" != "None" ]; then
            echo "‚úÖ Comando enviado a instancia $INSTANCE_ID (CommandId: $COMMAND_ID)"
            
            # Esperar a que el comando se complete (m√°ximo 10 minutos)
            echo "‚è≥ Esperando que se complete la actualizaci√≥n (puede tardar unos minutos)..."
            for i in {1..60}; do
              STATUS=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'Status' \
                --output text 2>/dev/null || echo "Pending")
              
              if [ "$STATUS" = "Success" ]; then
                echo "‚úÖ Instancia $INSTANCE_ID actualizada exitosamente"
                break
              elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
                echo "‚ö†Ô∏è  Instancia $INSTANCE_ID fall√≥ con estado: $STATUS"
                break
              fi
              
              if [ $i -lt 60 ]; then
                sleep 10
              fi
            done
            
            if [ "$STATUS" != "Success" ] && [ "$STATUS" != "Failed" ] && [ "$STATUS" != "Cancelled" ] && [ "$STATUS" != "TimedOut" ]; then
              echo "‚ö†Ô∏è  El comando a√∫n est√° ejecut√°ndose. Continuando..."
            fi
          else
            echo "‚ö†Ô∏è  No se pudo enviar comando a instancia $INSTANCE_ID"
            echo "üí° Aseg√∫rate de que SSM Agent est√© instalado y configurado"
          fi
        done

        echo "üí° Nota: El contenedor se reiniciar√° autom√°ticamente usando el mismo user-data script"
        echo "üí° Las migraciones se ejecutar√°n autom√°ticamente al iniciar el contenedor"

      - echo "‚úÖ Deploy completado. Instancias actualizadas sin crear nuevas"
