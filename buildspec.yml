post_build:
  commands:
    - echo "Push de imagen a ECR"
    - docker push $REPOSITORY_URI:$IMAGE_TAG
    - docker push $REPOSITORY_URI:latest
    - echo "âœ… Migraciones se ejecutarÃ¡n automÃ¡ticamente al iniciar el contenedor"
    - echo "ğŸ’¡ Esto no tiene costo adicional - las migraciones corren en el mismo contenedor"
    - echo "ğŸ”„ Actualizando instancias EC2 existentes (sin crear nuevas)..."
    - |
      source /tmp/build.env 2>/dev/null || SKIP_DEPLOY="false"

      if [ "$SKIP_DEPLOY" = "true" ]; then
        echo "â­ï¸  Saltando deployment - imagen no ha cambiado"
        exit 0
      fi

      TARGET_IMAGE="$REPOSITORY_URI:$IMAGE_TAG"
      PROJECT_NAME="${PROJECT_NAME:-trabajoya-prod}"
      CONTAINER_NAME="${PROJECT_NAME}-backend"

      echo "Imagen objetivo: $TARGET_IMAGE"
      echo "Nombre del contenedor: $CONTAINER_NAME"
      echo "Buscando instancias EC2..."

      if [ -n "$EC2_INSTANCE_ID" ]; then
        echo "âœ… Usando instancia especificada: $EC2_INSTANCE_ID"
        INSTANCE_IDS="$EC2_INSTANCE_ID"
      else
        echo "ğŸ” Buscando Auto Scaling Groups..."
        ASG_NAMES=$(aws autoscaling describe-auto-scaling-groups --query "AutoScalingGroups[?contains(AutoScalingGroupName, 'trabajoya') || contains(AutoScalingGroupName, 'prod')].AutoScalingGroupName" --output text 2>/dev/null || echo "")
        
        INSTANCE_IDS=""
        
        if [ -n "$ASG_NAMES" ]; then
          echo "âœ… Auto Scaling Groups encontrados: $ASG_NAMES"
          for ASG_NAME in $ASG_NAMES; do
            echo "   Procesando ASG: $ASG_NAME"
            ASG_INSTANCES=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" --query "AutoScalingGroups[0].Instances[?HealthStatus=='Healthy' && LifecycleState=='InService'].InstanceId" --output text 2>/dev/null || echo "")
            if [ -n "$ASG_INSTANCES" ]; then
              INSTANCE_IDS="$INSTANCE_IDS $ASG_INSTANCES"
            fi
          done
          INSTANCE_IDS=$(echo $INSTANCE_IDS | tr ' ' '\n' | sort -u | tr '\n' ' ' | xargs)
        fi
        
        if [ -z "$INSTANCE_IDS" ]; then
          echo "âš ï¸  No se encontraron instancias por ASG. Buscando directamente..."
          INSTANCE_IDS=$(aws ec2 describe-instances --filters "Name=instance-state-name,Values=running" "Name=tag:Name,Values=*trabajoya*" --query "Reservations[*].Instances[*].InstanceId" --output text 2>/dev/null || echo "")
          
          if [ -z "$INSTANCE_IDS" ]; then
            echo "âš ï¸  Buscando por CloudFormation stack..."
            STACK_NAME=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE --query "StackSummaries[?contains(StackName, 'trabajoya') && contains(StackName, 'prod')].StackName" --output text 2>/dev/null | head -n 1 || echo "")
            
            if [ -n "$STACK_NAME" ]; then
              echo "ğŸ” Stack encontrado: $STACK_NAME"
              INSTANCE_IDS=$(aws ec2 describe-instances --filters "Name=instance-state-name,Values=running" "Name=tag:aws:cloudformation:stack-name,Values=$STACK_NAME" --query "Reservations[*].Instances[*].InstanceId" --output text 2>/dev/null || echo "")
            fi
          fi
        fi
      fi

      if [ -z "$INSTANCE_IDS" ]; then
        echo "âš ï¸  No se encontraron instancias activas"
        exit 0
      fi

      echo "ğŸ“‹ Instancias encontradas: $INSTANCE_IDS"

      # Crear script de actualizaciÃ³n (sin usar JSON, directamente como script)
      cat > /tmp/update-script.sh << 'EOFSCRIPT'
      #!/bin/bash
      set -e

      echo "=== Iniciando actualizaciÃ³n del contenedor ==="

      # Obtener regiÃ³n y account ID
      REGION=$(curl -s http://169.254.169.254/latest/meta-data/placement/region)
      ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

      echo "RegiÃ³n: $REGION"
      echo "Account: $ACCOUNT_ID"

      # Login a ECR
      echo "Login a ECR..."
      aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin "$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com"

      # Pull nueva imagen
      echo "Descargando nueva imagen: TARGET_IMAGE_PLACEHOLDER"
      docker pull TARGET_IMAGE_PLACEHOLDER || {
        echo "âš ï¸  No se pudo descargar imagen especÃ­fica, intentando con latest..."
        docker pull REPOSITORY_PLACEHOLDER:latest
      }

      # Reiniciar contenedor si existe
      if docker ps --format '{{.Names}}' | grep -q '^CONTAINER_NAME_PLACEHOLDER$'; then
        echo "Reiniciando contenedor CONTAINER_NAME_PLACEHOLDER..."
        docker restart CONTAINER_NAME_PLACEHOLDER && echo "âœ… Contenedor reiniciado exitosamente" || {
          echo "âš ï¸  Fallo al reiniciar, deteniendo y removiendo..."
          docker stop CONTAINER_NAME_PLACEHOLDER
          docker rm CONTAINER_NAME_PLACEHOLDER
          echo "âš ï¸  Contenedor detenido - serÃ¡ recreado por user-data"
        }
      else
        echo "âš ï¸  Contenedor no estaba corriendo - serÃ¡ iniciado por user-data"
      fi

      echo "âœ… ActualizaciÃ³n completada"
      EOFSCRIPT

      # Reemplazar placeholders
      sed -i "s|TARGET_IMAGE_PLACEHOLDER|${TARGET_IMAGE}|g" /tmp/update-script.sh
      sed -i "s|REPOSITORY_PLACEHOLDER|${REPOSITORY_URI}|g" /tmp/update-script.sh
      sed -i "s|CONTAINER_NAME_PLACEHOLDER|${CONTAINER_NAME}|g" /tmp/update-script.sh

      # Leer el script completo como un solo string
      UPDATE_SCRIPT=$(cat /tmp/update-script.sh)

      # Actualizar cada instancia
      for INSTANCE_ID in $INSTANCE_IDS; do
        echo ""
        echo "ğŸš€ Actualizando instancia: $INSTANCE_ID"
        
        # Enviar comando usando el script directamente
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters commands="$UPDATE_SCRIPT" \
          --timeout-seconds 600 \
          --query 'Command.CommandId' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$COMMAND_ID" ] && [ "$COMMAND_ID" != "None" ]; then
          echo "âœ… Comando enviado (ID: $COMMAND_ID)"
          
          echo "â³ Esperando actualizaciÃ³n (mÃ¡ximo 5 minutos)..."
          for i in $(seq 1 30); do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… Instancia $INSTANCE_ID actualizada exitosamente"
              echo ""
              echo "ğŸ“‹ Output del comando:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text 2>/dev/null | head -20
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "âŒ Instancia $INSTANCE_ID fallÃ³: $STATUS"
              echo ""
              echo "ğŸ“‹ Error:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text 2>/dev/null
              echo ""
              echo "ğŸ“‹ Output:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text 2>/dev/null
              break
            fi
            
            if [ $i -lt 30 ]; then
              sleep 10
            fi
          done
        else
          echo "âŒ No se pudo enviar comando a $INSTANCE_ID"
          echo "ğŸ’¡ Verifica que SSM Agent estÃ© instalado y el rol tenga permisos"
        fi
      done

      echo ""
      echo "ğŸ’¡ Las migraciones se ejecutarÃ¡n automÃ¡ticamente al iniciar el contenedor"
