version: 0.2

env:
  variables:
    APP_CONFIG_SECRET_ID: /trabajoya-prod/app/config
    PROJECT_NAME: trabajoya-prod
    CONTAINER_PORT: "4000"

phases:
  pre_build:
    commands:
      - echo "Login a Amazon ECR"
      - aws --version
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPOSITORY_URI
      - export REPOSITORY_URI=$ECR_REPOSITORY_URI
      - export COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - export IMAGE_TAG=${COMMIT_HASH:-latest}
      - echo "Repositorio: $REPOSITORY_URI"
      - echo "Tag: $IMAGE_TAG"
      - cd $CODEBUILD_SRC_DIR

  build:
    commands:
      - echo "Build iniciado el $(date)"
      - docker build --no-cache --pull -f Dockerfile.prod -t $REPOSITORY_URI:$IMAGE_TAG .
      - docker tag $REPOSITORY_URI:$IMAGE_TAG $REPOSITORY_URI:latest

  post_build:
    commands:
      - echo "Push de imagen a ECR"
      - docker push $REPOSITORY_URI:$IMAGE_TAG
      - docker push $REPOSITORY_URI:latest

      - echo "Deploy por SSM (sin scripts)..."
      - |
        set -e

        TARGET_IMAGE="$REPOSITORY_URI:$IMAGE_TAG"
        DEPLOY_REGION="${AWS_DEFAULT_REGION:-us-east-1}"
        CONTAINER_NAME="${PROJECT_NAME}-backend"
        SECRET_ID="${APP_CONFIG_SECRET_ID}"
        PORT="${CONTAINER_PORT}"

        # Encontrar instancia(s)
        if [ -n "${EC2_INSTANCE_ID:-}" ]; then
          INSTANCE_IDS="$EC2_INSTANCE_ID"
        else
          ASG_NAMES=$(aws autoscaling describe-auto-scaling-groups \
            --query "AutoScalingGroups[?contains(AutoScalingGroupName,'trabajoya')||contains(AutoScalingGroupName,'prod')].AutoScalingGroupName" \
            --output text 2>/dev/null || echo "")
          INSTANCE_IDS=""
          if [ -n "$ASG_NAMES" ]; then
            for ASG_NAME in $ASG_NAMES; do
              ASG_INSTANCES=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" \
                --query "AutoScalingGroups[0].Instances[?HealthStatus=='Healthy'&&LifecycleState=='InService'].InstanceId" \
                --output text 2>/dev/null || echo "")
              if [ -n "$ASG_INSTANCES" ]; then
                INSTANCE_IDS="$INSTANCE_IDS $ASG_INSTANCES"
              fi
            done
          fi
        fi

        if [ -z "$INSTANCE_IDS" ]; then
          echo "No se encontraron instancias activas"
          exit 0
        fi

        echo "Instancias: $INSTANCE_IDS"
        echo "Imagen: $TARGET_IMAGE"
        echo "Secret: $SECRET_ID"

        # Comando remoto (inline, sin archivos)
        REMOTE_CMD=$(cat <<EOF
set -euo pipefail
REGION="$DEPLOY_REGION"
CONTAINER_NAME="$CONTAINER_NAME"
TARGET_IMAGE="$TARGET_IMAGE"
SECRET_ID="$SECRET_ID"
PORT="$PORT"

ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)
aws ecr get-login-password --region "\$REGION" | docker login --username AWS --password-stdin "\$ACCOUNT_ID.dkr.ecr.\$REGION.amazonaws.com"

docker pull "\$TARGET_IMAGE"

# Bajamos el JSON del secret y lo convertimos a env-file
CONFIG_JSON=\$(aws secretsmanager get-secret-value --region "\$REGION" --secret-id "\$SECRET_ID" --query SecretString --output text)

python3 - <<'PY'
import json, os, sys
s = os.environ.get("CONFIG_JSON")
if not s or s == "None":
  print("No CONFIG_JSON")
  sys.exit(1)
data = json.loads(s)
with open("/tmp/app.env", "w") as f:
  for k, v in data.items():
    if v is None: 
      continue
    v = str(v).replace("\\n","\\\\n")
    f.write(f"{k}={v}\\n")
PY

# Reinicio contenedor con env-file
docker stop "\$CONTAINER_NAME" 2>/dev/null || true
docker rm "\$CONTAINER_NAME" 2>/dev/null || true

docker run -d --name "\$CONTAINER_NAME" --restart unless-stopped -p "\$PORT:\$PORT" --env-file /tmp/app.env "\$TARGET_IMAGE"

docker ps --filter "name=\$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
docker logs --tail 50 "\$CONTAINER_NAME" || true
EOF
)

        # OJO: pasar CONFIG_JSON como env a python en remoto
        # Lo hacemos metiéndolo en el mismo comando con export.
        # Usamos base64 solo para evitar problemas de escape, pero NO guardamos ningún .sh.
        REMOTE_B64=$(printf "%s" "$REMOTE_CMD" | base64 -w 0)

        for INSTANCE_ID in $INSTANCE_IDS; do
          echo "Deploy en: $INSTANCE_ID"

          SSM_JSON=$(jq -n --arg cmd "$REMOTE_B64" '{
            commands: [
              "bash -lc '\''CMD=$(echo " + $cmd + " | base64 -d); export CONFIG_JSON=$(aws secretsmanager get-secret-value --region '"$DEPLOY_REGION"' --secret-id '"$SECRET_ID"' --query SecretString --output text); eval \"$CMD\"'\''"
            ]
          }')

          COMMAND_ID=$(aws ssm send-command \
            --region "$DEPLOY_REGION" \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "$SSM_JSON" \
            --timeout-seconds 600 \
            --query 'Command.CommandId' \
            --output text)

          echo "SSM CommandId: $COMMAND_ID"
          aws ssm wait command-executed --region "$DEPLOY_REGION" --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" || true

          echo "STDOUT:"
          aws ssm get-command-invocation --region "$DEPLOY_REGION" --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text || true
          echo "STDERR:"
          aws ssm get-command-invocation --region "$DEPLOY_REGION" --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardErrorContent' --output text || true
        done

artifacts:
  files:
    - "**/*"
